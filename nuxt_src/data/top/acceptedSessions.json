[
  {
    "id": "E14",
    "artifacts": {
      "youtube_embed_url": "//www.youtube.com/embed/xIQVnLzKG4U",
      "slides": {
        "other_url": "",
        "embed_url": "//slides.com/avasil/understanding-monix-observable-scalamatsuri2020/embed",
        "speakerdeck": {
          "data_id": "",
          "data_ratio": ""
        }
      }
    },
    "en": {
      "title": "Understanding Monix Observable",
      "detail": "Monix Observable is a streaming data type which marries ReactiveX with purely functional programming in Scala.\n\nLet’s dive deep into its internals, explain how and why it works and what are some of the less pleasant consequences of its design.",
      "language": "English",
      "length": 40,
      "tags": [
        "Functional Programming",
        " Software Design and Architecture",
        " Others"
      ],
      "keywords": [
        "Concurrency",
        "Streaming",
        "Internals"
      ],
      "speakers": [
        {
          "name": "Piotr Gawryś",
          "icon": "https://avatars3.githubusercontent.com/u/12383899?s=400&u=3f8d764e0dec2906239e2a846c45134ced27e2ec&v=4",
          "organization": "Software Engineer at VirtusLab",
          "speaker_experience": [
            "ScalaMatsuri 2019: https://www.youtube.com/watch?v=MeOs9SeO8-c",
            "flatMap(Oslo) 2019: https://www.youtube.com/watch?v=InctntW3CAA",
            "",
            "And the same talk on Scalar 2019"
          ],
          "contributes": [
            "https://github.com/monix/monix",
            "https://github.com/monix/monix-bio",
            "https://github.com/typelevel/cats-effect"
          ],
          "github": "Avasil",
          "twitter": "p_gawrys",
          "other_sns": ""
        }
      ]
    },
    "ja": {
      "title": "Monix Observableを理解する",
      "detail": "Monix Observableは、Reactive Xと純粋関数型プログラミングがScalaの縁で結婚したかのような、ストリームのデータ型です。\n\n今回その中身を詳しく見ながら、どういうコードになっているのか、なぜうまく動くのか、そしてあまり見目麗しくない設計にならざるを得なかった場所について紹介していきます。",
      "language": "English",
      "length": 40,
      "tags": [
        "Functional Programming",
        " Software Design and Architecture",
        " Others"
      ],
      "keywords": [
        "Concurrency",
        "Streaming",
        "Internals"
      ],
      "speakers": [
        {
          "name": "Piotr Gawryś",
          "icon": "https://avatars3.githubusercontent.com/u/12383899?s=400&u=3f8d764e0dec2906239e2a846c45134ced27e2ec&v=4",
          "organization": "Software Engineer at VirtusLab",
          "speaker_experience": [
            "ScalaMatsuri 2019: https://www.youtube.com/watch?v=MeOs9SeO8-c",
            "flatMap(Oslo) 2019: https://www.youtube.com/watch?v=InctntW3CAA",
            "",
            "And the same talk on Scalar 2019"
          ],
          "contributes": [
            "https://github.com/monix/monix",
            "https://github.com/monix/monix-bio",
            "https://github.com/typelevel/cats-effect"
          ],
          "github": "Avasil",
          "twitter": "p_gawrys",
          "other_sns": ""
        }
      ]
    }
  },
  {
    "id": "E16",
    "artifacts": {
      "youtube_embed_url": "//www.youtube.com/embed/83yyIQVBwFQ",
      "slides": {
        "other_url": "",
        "embed_url": "",
        "speakerdeck": {
          "data_id": "",
          "data_ratio": ""
        }
      }
    },
    "en": {
      "title": "# Touch the Types - Types at your fingertips in IntelliJ Scala",
      "detail": "Scala's powerful type system helps you develop complex programs with less runtime errors. But sometimes understanding the types while programming becomes a challenge onto itself. I will show you how the IntelliJ Scala plugin helps you get a grip on your types to support your development flow. \n\n I describe some ways to get the most out of Scala's type system in the IntelliJ Scala plugin",
      "language": "English",
      "length": 40,
      "tags": [
        "Functional Programming",
        " Tools",
        " Scala Beginners (~1year)"
      ],
      "keywords": [
        "intellij",
        "types",
        "tools"
      ],
      "speakers": [
        {
          "name": "Justin Kaeser",
          "icon": "https://en.gravatar.com/userimage/40703495/21def3f397a6976d1f9ae5239e0da870.jpg?size=200",
          "organization": "JetBrains",
          "speaker_experience": [
            "Scala Days, Scale By The Bay, Scala World (and many others)",
            "",
            "Integrating Developer Experiences talk at Scala Days:",
            "https://portal.klewel.com/watch/webcast/scala-days-2019/talk/22/"
          ],
          "contributes": [
            "Scala plugin for IntelliJ IDEA: https://github.com/JetBrains/intellij-scala",
            "Build Server Protocol: https://github.com/build-server-protocol/build-server-protocol",
            "Gringotts: https://github.com/MinecraftWars/Gringotts"
          ],
          "github": "jastice",
          "twitter": "ebenwert",
          "other_sns": "https://www.linkedin.com/in/justinkaeser/"
        }
      ]
    },
    "ja": {
      "title": "型に触ろう - IntelliJ Scalaなら、すぐそこに型がある",
      "detail": "Scalaの強力な型システムは、複雑なプログラムでも実行時のエラーが少ないものを開発することを可能とします。\nしかし時として、プログラミングもして型も理解しなければならないのは面倒なことです。\n\nそこでIntelliJ Scala pluginによって、開発者がどのように型を把握したり、開発フローを改善できるかお見せします。\n\nIntelliJ Scalaプラグインで、Scalaの型システムを使い倒す方法を紹介します。",
      "language": "English",
      "length": 40,
      "tags": [
        "Functional Programming",
        " Tools",
        " Scala Beginners (~1year)"
      ],
      "keywords": [
        "intellij",
        "types",
        "tools"
      ],
      "speakers": [
        {
          "name": "Justin Kaeser",
          "icon": "https://en.gravatar.com/userimage/40703495/21def3f397a6976d1f9ae5239e0da870.jpg?size=200",
          "organization": "JetBrains",
          "speaker_experience": [
            "Scala Days, Scale By The Bay, Scala World (and many others)",
            "",
            "Integrating Developer Experiences talk at Scala Days:",
            "https://portal.klewel.com/watch/webcast/scala-days-2019/talk/22/"
          ],
          "contributes": [
            "Scala plugin for IntelliJ IDEA: https://github.com/JetBrains/intellij-scala",
            "Build Server Protocol: https://github.com/build-server-protocol/build-server-protocol",
            "Gringotts: https://github.com/MinecraftWars/Gringotts"
          ],
          "github": "jastice",
          "twitter": "ebenwert",
          "other_sns": "https://www.linkedin.com/in/justinkaeser/"
        }
      ]
    }
  },
  {
    "id": "J6",
    "artifacts": {
      "youtube_embed_url": "//www.youtube.com/embed/xosWHE97Gik",
      "slides": {
        "other_url": "",
        "embed_url": "",
        "speakerdeck": {
          "data_id": "9f8b1f77b61e4b0fa0d5c4d75b7dd8b2",
          "data_ratio": "1.37081659973226"
        }
      }
    },
    "en": {
      "title": " Explain model-driven design based on business patterns using Scala",
      "detail": "\"Model-Driven Design Using Business Patterns\" by Pavel Hruby published in 2006 is a book that provides useful patterns related to Domain-Driven Design(DDD). This book introduces universal modeling patterns for business applications called REA (Resource, Event, Agent).\nBased on these REA structures, behavior patterns such as \"date\" and \"classification\" are also useful. I'm interested in how Scala expresses the patterns invented 10 years ago. This time I want to discuss some patterns from REA.",
      "language": "Japanese",
      "length": 40,
      "tags": [
        "Software Design and Architecture"
      ],
      "keywords": [
        "DDD Modeling REA"
      ],
      "speakers": [
        {
          "name": "Junichi Kato",
          "icon": "/img/speakers/J6.jpg",
          "organization": "Chatwork Co., Ltd. Tech Lead",
          "speaker_experience": [
            "ScalaMatsuri 2019, AWS DevDay etc."
          ],
          "contributes": [],
          "github": "j5ik2o",
          "twitter": "j5ik2o",
          "other_sns": "twiiter"
        }
      ]
    },
    "ja": {
      "title": "Scalaで解説する、ビジネスパターンによるモデル駆動設計",
      "detail": " 2007年発刊のPavel Hruby著「ビジネスパターンによるモデル駆動設計」はドメイン駆動設計に関連する有益なパターンを提供している書籍です。この書籍ではREA(Resource, Event, Agent)というビジネスアプリケーションにおいて普遍的なモデリングパターンを紹介しています。こういったREA構造を基に期日や分類などの振る舞いのパターンも役に立ちます。10年に考案されたこれらのパターンをScalaで現代に再現するにはどうするべきか、私は興味を持っています。REAからいくつかのパターンを抜粋して議論したいと思います。",
      "language": "Japanese",
      "length": 40,
      "tags": [
        "Software Design and Architecture"
      ],
      "keywords": [
        "DDD Modeling REA"
      ],
      "speakers": [
        {
          "name": "かとじゅん",
          "icon": "/img/speakers/J6.jpg",
          "organization": "Chatwork株式会社 テックリード",
          "speaker_experience": [
            "ScalaMatsuri 2019, AWS DevDay など"
          ],
          "contributes": [],
          "github": "j5ik2o",
          "twitter": "j5ik2o",
          "other_sns": "twiiter"
        }
      ]
    }
  },
  {
    "id": "E27",
    "artifacts": {
      "youtube_embed_url": "//www.youtube.com/embed/oLvdhVNIC3k",
      "slides": {
        "other_url": "",
        "embed_url": "//www.slideshare.net/slideshow/embed_code/key/xz2uXXgLJzKqeo",
        "speakerdeck": {
          "data_id": "",
          "data_ratio": ""
        }
      }
    },
    "en": {
      "title": "Caliban: Functional GraphQL Library for Scala",
      "detail": "Caliban is a library for GraphQL in Scala. It was designed with the goal of reducing boilerplate to a minimum while exposing a purely functional interface. In this talk, we’ll discover how to create a simple GraphQL API from the ground up, then we’ll dig into advanced features such as query optimization and middlewares. Finally, we will take a look at the recently released GraphQL client support.",
      "language": "English",
      "length": 40,
      "tags": [
        "Functional Programming",
        " Software Design and Architecture"
      ],
      "keywords": [
        "GraphQL",
        "FP",
        "ZIO"
      ],
      "speakers": [
        {
          "name": "Pierre Ricadat",
          "icon": "/img/speakers/E27.jpg",
          "organization": "",
          "speaker_experience": [
            "Functional Scala 2019 (London)",
            "video: https://www.youtube.com/watch?v=OC8PbviYUlQ",
            "slides: https://www.slideshare.net/PierreRicadat/designing-a-functional-graphql-library-204680947"
          ],
          "contributes": [
            "https://github.com/ghostdogpr/caliban",
            "https://github.com/zio/zio",
            "https://github.com/zio/zio-akka-cluster"
          ],
          "github": "ghostdogpr",
          "twitter": "ghostdogpr",
          "other_sns": ""
        }
      ]
    },
    "ja": {
      "title": "Caliban: 関数型GraphQLライブラリの設計",
      "detail": "GraphQL は REST に替わる公開API の強力な選択肢になりつつあります。このトークでは Scala で GraphQL バックエンドを記述するための関数型ライブラリ Caliban を紹介します。「どうやってボイラープレートを最小化したか」「明示的なエラーをどう持たせるか」「pub/sub処理」など、スクラッチからライブラリを開発しながら設計方針を説明します。",
      "language": "English",
      "length": 40,
      "tags": [
        "Functional Programming",
        " Software Design and Architecture"
      ],
      "keywords": [
        "GraphQL",
        "FP",
        "ZIO"
      ],
      "speakers": [
        {
          "name": "Pierre Ricadat",
          "icon": "/img/speakers/E27.jpg",
          "organization": "",
          "speaker_experience": [
            "Functional Scala 2019 (London)",
            "video: https://www.youtube.com/watch?v=OC8PbviYUlQ",
            "slides: https://www.slideshare.net/PierreRicadat/designing-a-functional-graphql-library-204680947"
          ],
          "contributes": [
            "https://github.com/ghostdogpr/caliban",
            "https://github.com/zio/zio",
            "https://github.com/zio/zio-akka-cluster"
          ],
          "github": "ghostdogpr",
          "twitter": "ghostdogpr",
          "other_sns": ""
        }
      ]
    }
  },
  {
    "id": "J7",
    "artifacts": {
      "youtube_embed_url": "//www.youtube.com/embed/BFW4YRr6m58",
      "slides": {
        "other_url": "",
        "embed_url": "",
        "speakerdeck": {
          "data_id": "d44b879378314bec9eff1bf7ce86036d",
          "data_ratio": "1.77777777777778"
        }
      }
    },
    "en": {
      "title": "Big Timesavers for Busy Scala Developers",
      "detail": "Introduces plugins and bots, maybe not well-known, useful for daily Scala development.\nBe more productive Scala developer together !!\n\n* Finish deprecated APIs rewrites in a flash\n* Don't repeat easy-to-miss coding errors and fix them\n* Get relief from watching releases of tons of libraries\n\nThis talk introduces various convenient tools and methods, e.g. to auto-fix common Scala programming pitfalls.\nI hope those will enhance your productivity as Scala developers for many years to come.",
      "language": "Japanese",
      "length": 40,
      "tags": [
        "Tools",
        " Best Practices",
        " Scala Beginners (~1year)"
      ],
      "keywords": [
        "productivity hacks",
        "code quality",
        "workflow"
      ],
      "speakers": [
        {
          "name": "TATSUNO Yasuhiro",
          "icon": "https://pbs.twimg.com/profile_images/1065225327763320832/px0zvxM5_400x400.jpg",
          "organization": "Chatwork Co., Ltd.",
          "speaker_experience": [
            "ScalaMatsuri Unconference (2017)",
            "東京Node学園/Tokyo Node Festival (2018)",
            "https://speakerdeck.com/exoego/serverless-in-scala-on-node-dot-js",
            "名古屋フロントエンドユーザーグループ TypeScript勉強会 (2019)",
            "https://speakerdeck.com/exoego/easing-code-review-with-lint-for-typescript"
          ],
          "contributes": [
            "https://github.com/scala-js/scala-js",
            "https://github.com/serverless/serverless",
            "https://github.com/fomantic/Fomantic-UI"
          ],
          "github": "exoego",
          "twitter": "exoego",
          "other_sns": ""
        }
      ]
    },
    "ja": {
      "title": "忙しいScala開発者の超時間節約術",
      "detail": "日々のScala開発で役立つのに意外と知られていないプラグインやボットを紹介します。\nみんなでより生産性の高いScala開発者になろう！\n\n・廃止APIの大規模な書き換えを一瞬で済ませる\n・見落としやすいコーディングエラーを再発させず、確実に直す\n・たくさんのライブラリのリリースを追い続ける日々から解放される\n\nこのトークでは、Scalaプログラミングでやりがちなミスを自動修正したりといった、さまざまな便利ツールや考え方を紹介します。\nこれから何年もScalaで開発をしていくあなたの生産性をきっと底上げしてくれるでしょう。",
      "language": "Japanese",
      "length": 40,
      "tags": [
        "Tools",
        " Best Practices",
        " Scalaビギナー（Scala歴1年くらいまで）"
      ],
      "keywords": [
        "productivity hacks",
        "code quality",
        "workflow"
      ],
      "speakers": [
        {
          "name": "立野靖博",
          "icon": "https://pbs.twimg.com/profile_images/1065225327763320832/px0zvxM5_400x400.jpg",
          "organization": "Chatwork株式会社",
          "speaker_experience": [
            "ScalaMatsuri Unconference (2017)",
            "東京Node学園/Tokyo Node Festival (2018)",
            "https://speakerdeck.com/exoego/serverless-in-scala-on-node-dot-js",
            "名古屋フロントエンドユーザーグループ TypeScript勉強会 (2019)",
            "https://speakerdeck.com/exoego/easing-code-review-with-lint-for-typescript"
          ],
          "contributes": [
            "https://github.com/scala-js/scala-js",
            "https://github.com/serverless/serverless",
            "https://github.com/fomantic/Fomantic-UI"
          ],
          "github": "exoego",
          "twitter": "exoego",
          "other_sns": ""
        }
      ]
    }
  },
  {
    "id": "E30",
    "artifacts": {
      "youtube_embed_url": "//www.youtube.com/embed/peWo4bsTV9A",
      "youtube_embed_url_2": "//www.youtube.com/embed/8FJqUncYSdA",
      "slides": {
        "other_url": "",
        "embed_url": "//pjurczenko.github.io/modern-jvm-multithreading.html#/",
        "speakerdeck": {
          "data_id": "",
          "data_ratio": ""
        }
      }
    },
    "en": {
      "title": "Modern JVM Multithreading",
      "detail": "In this presentation I will show what might be taken into consideration when writing a modern JVM application using Scala language. What are the differences between green threads and fibers? What kind of thread pools and how many of them should be used? Can we have a non-blocking communication with relational databases? Can we decouple our domain logic from asynchrony? Is it possible to have a reasonable stack-trace in asynchronous code? These are the main questions I'd like to address in the presentation.",
      "language": "English",
      "length": 100,
      "tags": [
        "Best Practices",
        " Software Design and Architecture"
      ],
      "keywords": [
        "Multithreading",
        "Concurrency",
        "Reactive"
      ],
      "speakers": [
        {
          "name": "Paweł Jurczenko",
          "icon": "https://avatars.githubusercontent.com/u/12970160",
          "organization": "Software Engineer at Allegro.pl",
          "speaker_experience": [
            "1. Allegro Tech Meeting 2019: https://youtu.be/Wjg3UxYmw3I",
            "2. Poznań Java User Group: https://youtu.be/uBIKmB0NyGE",
            "3. Allegro Tech Talks #19: https://www.facebook.com/allegro.tech/videos/446254389281330"
          ],
          "contributes": [],
          "github": "pjurczenko",
          "twitter": "pawel_jurczenko",
          "other_sns": ""
        }
      ]
    },
    "ja": {
      "title": "モダンなJVMマルチスレッド",
      "detail": "このプレゼンテーションではScalaによるモダンなJVMアプリケーションを書くときに考慮する事柄について紹介します。グリーンスレッドとファイバーの違いはなんでしょうか。スレッドプールとは何か、またスレッドプール数はいくつにすべきでしょうか。リレーショナルデータベースとのノンブロッキングな通信は可能でしょうか。ドメインロジックを非同期から切り離すことが可能でしょうか。これらの問い対してこのプレゼンテーションでお伝えします。",
      "language": "English",
      "length": 100,
      "tags": [
        "Best Practices",
        " Software Design and Architecture"
      ],
      "keywords": [
        "Multithreading",
        "Concurrency",
        "Reactive"
      ],
      "speakers": [
        {
          "name": "Paweł Jurczenko",
          "icon": "https://avatars.githubusercontent.com/u/12970160",
          "organization": "Software Engineer at Allegro.pl",
          "speaker_experience": [
            "1. Allegro Tech Meeting 2019: https://youtu.be/Wjg3UxYmw3I",
            "2. Poznań Java User Group: https://youtu.be/uBIKmB0NyGE",
            "3. Allegro Tech Talks #19: https://www.facebook.com/allegro.tech/videos/446254389281330"
          ],
          "contributes": [],
          "github": "pjurczenko",
          "twitter": "pawel_jurczenko",
          "other_sns": ""
        }
      ]
    }
  },
  {
    "id": "J8",
    "artifacts": {
      "youtube_embed_url": "//www.youtube.com/embed/LI7IwzVy2dI",
      "slides": {
        "other_url": "",
        "embed_url": "//www.slideshare.net/slideshow/embed_code/key/56vFz2wmhTTFRN",
        "speakerdeck": {
          "data_id": "",
          "data_ratio": ""
        }
      }
    },
    "en": {
      "title": "Scala for Everything: From Frontend to Backend Applications",
      "detail": "Scala is a powerful language; You can build frontend applications with Scala.js, and efficient backend application servers for JVM. In this session, we will learn how to build everything with Scala by using Airframe OSS framework. \n\nAirframe is a library designed for maximizing the advantages of Scala as a hybrid of object-oriented and functional programming language. In this session, we will learn how to use Airframe to build REST APIs and RPC services, and how to create frontend applications in Scala.js that interact with the servers using functional interfaces for dynamically updating web pages.",
      "language": "Japanese",
      "length": 40,
      "tags": [
        "Tools",
        " Scala Beginners (~1year)",
        " Microservices"
      ],
      "keywords": [
        "Airframe Scala.js "
      ],
      "speakers": [
        {
          "name": "Taro L. Saito",
          "icon": "https://pbs.twimg.com/profile_images/652040869705461760/eIm1fxaM_400x400.jpg",
          "organization": "Arm Treasure Data",
          "speaker_experience": [
            "- Scala Matsuri",
            "- Conferenceなど"
          ],
          "contributes": [
            "Airframe, sbt-sonatype, MessagePackなど"
          ],
          "github": "xerial",
          "twitter": "taroleo",
          "other_sns": ""
        }
      ]
    },
    "ja": {
      "title": "Scala無双: フロントエンドもバックエンドも全てScalaでなぎ倒せ",
      "detail": "Scalaは強力な言語で、Scala.jsによるWebブラウザ用のフロントエンドから、JVMで動くサーバーなど高性能なバックエンドプログラミングも可能です。このセッションでは、OSSであるAirframeフレームワークを用いて、アプリケーションを「全て」Scalaで作りきる手法を紹介します。\n\nAirframeはScalaのオブジェクト指向＋関数型のハイブリッドという特徴を最大限活かすようにデザインされたライブラリです。このセッションでは、Airframeを使うことで、Scalaの構文そのままにREST APIやRPCサービスを構築し、Scala.jsからサーバー側の関数を呼び出して動的にウェブページを更新するフロントエンドコードを作成する方法を学びます。",
      "language": "Japanese",
      "length": 40,
      "tags": [
        "Tools",
        " Scalaビギナー（Scala歴1年くらいまで）",
        " Microservices"
      ],
      "keywords": [
        "Airframe Scala.js "
      ],
      "speakers": [
        {
          "name": "Taro L. Saito",
          "icon": "https://pbs.twimg.com/profile_images/652040869705461760/eIm1fxaM_400x400.jpg",
          "organization": "Arm Treasure Data",
          "speaker_experience": [
            "- Scala Matsuri",
            "- Conferenceなど"
          ],
          "contributes": [
            "Airframe, sbt-sonatype, MessagePackなど"
          ],
          "github": "xerial",
          "twitter": "taroleo",
          "other_sns": ""
        }
      ]
    }
  },
  {
    "id": "J10",
    "artifacts": {
      "youtube_embed_url": "//www.youtube.com/embed/zBxX-Adn5XI",
      "slides": {
        "other_url": "",
        "embed_url": "",
        "speakerdeck": {
          "data_id": "937be872f8ad4f7a978d606ff64ea9dd",
          "data_ratio": "1.6"
        }
      }
    },
    "en": {
      "title": "Re-architecting in GANMA!",
      "detail": "GANMA! is an original manga distribution service that implemented by Scala.\n7 years have passed since starting a project and have a lot of technical debt.\nIn this session, we will talk struggle to re-architecture.",
      "language": "Japanese",
      "length": 40,
      "tags": [
        "DevOps",
        " Software Design and Architecture",
        " Microservices"
      ],
      "keywords": [
        "DDD",
        "Rearchitecture",
        "Kubernetes"
      ],
      "speakers": [
        {
          "name": "Naoki Aoyama - @aoiroaoino",
          "icon": "https://avatars0.githubusercontent.com/u/2589034?s=460&v=4",
          "organization": "株式会社セプテーニ・オリジナル",
          "speaker_experience": [
            "おもな登壇:",
            "",
            "ScalaMatsuri (2018),  Scala関西Summit (2016, 2017, 2019), Scala秋祭り, など",
            "",
            "おもな資料:",
            "",
            "Lens の基本と基礎 (ScalaMatsuri 2017 アンカンファレンス)",
            "https://www.slideshare.net/AoiroAoino/van-laarhoven-lens-72584231 ",
            "",
            "Purely Functional Play Framework Application (ScalaMatsuri 2018)",
            "https://www.slideshare.net/AoiroAoino/purelyfunctionalplayframeworkapplication",
            "",
            "Scala における継続モナドの実装と活用 (Scala秋祭り)",
            "https://speakerdeck.com/aoiroaoino/scala-niokeruji-sok-monadofalseshi-zhuang-tohuo-yong"
          ],
          "contributes": [
            "https://github.com/aoiroaoino/guttural"
          ],
          "github": "aoiroaoino",
          "twitter": "AoiroAoino",
          "other_sns": ""
        }
      ]
    },
    "ja": {
      "title": "Re-architecting in GANMA!",
      "detail": "GANMA! は2013年にサービスを開始したマンガ配信サービスで、バックエンドはほぼ全て Scala で実装されています。リリースから7年目を迎え、いよいよ本腰を入れて技術的負債と向き合う時がやってきました。このセッションでは現在抱えている課題とそれをどう解消しようと取り組んでいるのかをご紹介します。",
      "language": "Japanese",
      "length": 40,
      "tags": [
        "DevOps",
        " Software Design and Architecture",
        " Microservices"
      ],
      "keywords": [
        "DDD",
        "Rearchitecture",
        "Kubernetes"
      ],
      "speakers": [
        {
          "name": "Naoki Aoyama - @aoiroaoino",
          "icon": "https://avatars0.githubusercontent.com/u/2589034?s=460&v=4",
          "organization": "株式会社セプテーニ・オリジナル",
          "speaker_experience": [
            "おもな登壇:",
            "",
            "ScalaMatsuri (2018),  Scala関西Summit (2016, 2017, 2019), Scala秋祭り, など",
            "",
            "おもな資料:",
            "",
            "Lens の基本と基礎 (ScalaMatsuri 2017 アンカンファレンス)",
            "https://www.slideshare.net/AoiroAoino/van-laarhoven-lens-72584231 ",
            "",
            "Purely Functional Play Framework Application (ScalaMatsuri 2018)",
            "https://www.slideshare.net/AoiroAoino/purelyfunctionalplayframeworkapplication",
            "",
            "Scala における継続モナドの実装と活用 (Scala秋祭り)",
            "https://speakerdeck.com/aoiroaoino/scala-niokeruji-sok-monadofalseshi-zhuang-tohuo-yong"
          ],
          "contributes": [
            "https://github.com/aoiroaoino/guttural"
          ],
          "github": "aoiroaoino",
          "twitter": "AoiroAoino",
          "other_sns": ""
        }
      ]
    }
  },
  {
    "id": "J12",
    "artifacts": {
      "youtube_embed_url": "//www.youtube.com/embed/AxdKpXsvUxk",
      "slides": {
        "other_url": "",
        "embed_url": "//y-yu.github.io/scalamatsuri2020/scalamatsuri2020.pdf",
        "speakerdeck": {
          "data_id": "",
          "data_ratio": ""
        }
      }
    },
    "en": {
      "title": "A interpreter handling over effects for Eff",
      "detail": "We consider that we use DBIO(in Slick) and Either as DBIO[Either[E, A]], it cannot allow us to implement that “if the result would be Either.Left then turn it into DBIO.failed and rollback!” without changing any interfaces because monads(or monad transformers) and its processes are coupled tightly. On the other hands in Extensible Effects(Eff) we add types as effects to the effect stack and interpreters process the types. Since effects and interpreters are separated so we can implement an interpreter which process two effects at one shot. I'll talk about that topic in this session.",
      "language": "Japanese",
      "length": 40,
      "tags": [
        "Functional Programming"
      ],
      "keywords": [
        "Extensible Effects,Effect system,Effect abstraction"
      ],
      "speakers": [
        {
          "name": "YOSHIMURA Hikaru",
          "icon": "https://pbs.twimg.com/profile_images/1198179592520921088/w0T_BnoX_400x400.jpg",
          "organization": "株式会社リクルートマーケティングパートナーズ エンジニア",
          "speaker_experience": [
            "try!Swift2019（protocol/extensionにジェネリクスを入れたい）",
            "・https://www.youtube.com/watch?v=Urt1VJShbL4&list=PLCl5NM4qD3u_L8dJrWYbLB8FcUaoAHDFt&index=33&t=0s",
            "・https://github.com/y-yu/try-swift-slide",
            "",
            "ScalaMatsuri2019（Fujitask meets Extensible Effects, アンカンファレンス）",
            "・https://github.com/y-yu/fujitask-eff-slide/"
          ],
          "contributes": [
            "Scala text",
            "・https://github.com/scala-text 主にPDF版のメンテ",
            "",
            "The Rust Programming Language 2nd Edition（日本語訳）",
            "・https://github.com/rust-lang-ja/book-ja-pdf PDF版のメンテ",
            "",
            "Erlang in enger（日本語訳）",
            "・https://github.com/ymotongpoo/erlang-in-anger 日本語翻訳版のPDFメンテ"
          ],
          "github": "y-yu",
          "twitter": "_yyu_",
          "other_sns": ""
        }
      ]
    },
    "ja": {
      "title": "エフェクトを跨ぐインタープリター",
      "detail": "SlickのDBIOとEitherを組み合せたDBIO[Either[E, A]]のような型があるとき、モナドやモナドトランスフォーマーはエフェクトを表すDBIOのような型とそれの処理が密に結合しているため「Either.LeftのときはDBIO.failedにしロールバックして！」といったエフェクトに跨がる処理をインターフェースの変更をせずに書くことができない。Extensible Effects（Eff）はエフェクトスタックにエフェクトを表す型を追加し、インタープリターがそれを処理する。エフェクトの型と処理（インタープリター）は分離されているため、DBIOとEitherのようにエフェクトを跨ぐようなインタープリターを書くことができる。このセッションではこのテーマについてモナドやモナドトランスフォーマーの議論も交えながら解説する。",
      "language": "Japanese",
      "length": 40,
      "tags": [
        "Functional Programming"
      ],
      "keywords": [
        "Extensible Effects,Effect system,Effect abstraction"
      ],
      "speakers": [
        {
          "name": "吉村 優",
          "icon": "https://pbs.twimg.com/profile_images/1198179592520921088/w0T_BnoX_400x400.jpg",
          "organization": "株式会社リクルートマーケティングパートナーズ エンジニア",
          "speaker_experience": [
            "try!Swift2019（protocol/extensionにジェネリクスを入れたい）",
            "・https://www.youtube.com/watch?v=Urt1VJShbL4&list=PLCl5NM4qD3u_L8dJrWYbLB8FcUaoAHDFt&index=33&t=0s",
            "・https://github.com/y-yu/try-swift-slide",
            "",
            "ScalaMatsuri2019（Fujitask meets Extensible Effects, アンカンファレンス）",
            "・https://github.com/y-yu/fujitask-eff-slide/"
          ],
          "contributes": [
            "Scala text",
            "・https://github.com/scala-text 主にPDF版のメンテ",
            "",
            "The Rust Programming Language 2nd Edition（日本語訳）",
            "・https://github.com/rust-lang-ja/book-ja-pdf PDF版のメンテ",
            "",
            "Erlang in enger（日本語訳）",
            "・https://github.com/ymotongpoo/erlang-in-anger 日本語翻訳版のPDFメンテ"
          ],
          "github": "y-yu",
          "twitter": "_yyu_",
          "other_sns": ""
        }
      ]
    }
  },
  {
    "id": "J14",
    "artifacts": {
      "youtube_embed_url": "//www.youtube.com/embed/KAtLZ1Mwioc",
      "slides": {
        "other_url": "",
        "embed_url": "",
        "speakerdeck": {
          "data_id": "32e8e448ddf140548cc6004f190756ac",
          "data_ratio": "1.77777777777778"
        }
      }
    },
    "en": {
      "title": "Expressing complex domain regions and boundaries with 'modular monoliths'",
      "detail": "The architecture must change constantly, considering three requirements: organizational growth, domain and performance.\nHowever, to implement microservices at startup, it can be difficult to meet all the requirements.\nWe will explain how to realize context boundaries and reduce the pain of service division using \"modular monolith\" in Scala.",
      "language": "Japanese",
      "length": 40,
      "tags": [
        "Best Practices",
        " Software Design and Architecture"
      ],
      "keywords": [
        "modular monoliths",
        "clean architecture"
      ],
      "speakers": [
        {
          "name": "Shoma Takeo - @showmant",
          "icon": "https://avatars2.githubusercontent.com/u/5019215?s=460&v=4",
          "organization": "アルプ株式会社 取締役",
          "speaker_experience": [
            "Scala秋祭り"
          ],
          "contributes": [],
          "github": "showmant",
          "twitter": "showmant_",
          "other_sns": ""
        }
      ]
    },
    "ja": {
      "title": "モジュラモノリスで表現する複雑なドメイン領域と境界",
      "detail": "アーキテクチャは組織成長、ドメイン、パフォーマンスの3つの要件を考慮して常に変化する必要があります。\nしかしながら、スタートアップでマイクロサービスを導入するために、3つの要件全てを満たすには時間の制約や経験値から判断が困難なこともあります。\nこのセッションでは「モジュラモノリス」を採用するに至った経緯、Scalaでのコンテキスト境界の実現方法、サービス分断の痛みを軽減する工夫などを解説していきます。",
      "language": "Japanese",
      "length": 40,
      "tags": [
        "Best Practices",
        " Software Design and Architecture"
      ],
      "keywords": [
        "modular monoliths",
        "clean architecture"
      ],
      "speakers": [
        {
          "name": "竹尾 正馬 - @showmant",
          "icon": "https://avatars2.githubusercontent.com/u/5019215?s=460&v=4",
          "organization": "アルプ株式会社 取締役",
          "speaker_experience": [
            "Scala秋祭り"
          ],
          "contributes": [],
          "github": "showmant",
          "twitter": "showmant_",
          "other_sns": ""
        }
      ]
    }
  },
  {
    "id": "E36",
    "artifacts": {
      "youtube_embed_url": "//www.youtube.com/embed/s4J3aaXsuH8",
      "slides": {
        "other_url": "",
        "embed_url": "//www.slideshare.net/slideshow/embed_code/key/xANpWhuS3XTblZ",
        "speakerdeck": {
          "data_id": "",
          "data_ratio": ""
        }
      }
    },
    "en": {
      "title": "Friendly Functional Programming",
      "detail": "Functional programming is one of the possible paradigm that we can use to write applications using Scala, \nIn this talk you will learn about: \n* The benefits of using Functional programming approach\n* The type classes in Scala\n* And the common functional abstractions: semigroup, monoid, functor, applicative, and monad\n\nThe challenge that the newcomers who were writing imperative code and want to start using Scala is: to change the way of thinking and reasoning about the code in a Functional way, in this talk I will go through the details and explain functional programming paradigm and how to work with type classes in Scala.",
      "language": "English",
      "length": 40,
      "tags": [
        "Functional Programming",
        " Best Practices",
        " Scala Beginners (~1year)"
      ],
      "keywords": [
        "Functional programming",
        "Scala",
        "Abstraction "
      ],
      "speakers": [
        {
          "name": "Wiem Zine Elabidine",
          "icon": "/img/speakers/E36.png",
          "organization": "Software Enginner / MOIA",
          "speaker_experience": [
            "Scalar conference: https://www.youtube.com/watch?v=d6WWmia0BPM&list=PL8NC5lCgGs6MYG0hR_ZOhQLvtoyThURka",
            "Scala Days: https://www.youtube.com/watch?v=hh9SYl-IfIc",
            "Bee Scala: https://www.youtube.com/watch?v=v2JsK1M--3k",
            ""
          ],
          "contributes": [
            "https://github.com/zio/zio"
          ],
          "github": "wi101",
          "twitter": "WiemZin",
          "other_sns": ""
        }
      ]
    },
    "ja": {
      "title": "フレンドリーな関数型プログラミング",
      "detail": "関数型プログラミングは、Scalaを使ってアプリケーションを書くときに採用可能なパラダイムの一つです。\n\nこのトークでは、以下のことを学ぶことができます。\n- 関数型プログラミング的な手法の利点\n- Scalaにおける型クラス\n- よくある関数型の抽象化: semigroup, monoid, functor, applicative, そして monad\n\n今は命令型のコードを書いている、Scalaを使い始めたい方にとって、大変なこととはなんでしょうか。\nそれは、関数型なコードについて考えたり、その動作の推論方法を変えることです。\n\nこのトークでは、関数型プログラミングのパラダイムや、Scalaにとっての型クラスの働きについて詳細をざっと紹介し、解説します。",
      "language": "English",
      "length": 40,
      "tags": [
        "Functional Programming",
        " Best Practices",
        " Scala Beginners (~1year)"
      ],
      "keywords": [
        "Functional programming",
        "Scala",
        "Abstraction "
      ],
      "speakers": [
        {
          "name": "Wiem Zine Elabidine",
          "icon": "/img/speakers/E36.png",
          "organization": "Software Enginner / MOIA",
          "speaker_experience": [
            "Scalar conference: https://www.youtube.com/watch?v=d6WWmia0BPM&list=PL8NC5lCgGs6MYG0hR_ZOhQLvtoyThURka",
            "Scala Days: https://www.youtube.com/watch?v=hh9SYl-IfIc",
            "Bee Scala: https://www.youtube.com/watch?v=v2JsK1M--3k",
            ""
          ],
          "contributes": [
            "https://github.com/zio/zio"
          ],
          "github": "wi101",
          "twitter": "WiemZin",
          "other_sns": ""
        }
      ]
    }
  },
  {
    "id": "J19",
    "artifacts": {
      "youtube_embed_url": "//www.youtube.com/embed/HI2XdC4qL1A",
      "slides": {
        "other_url": "",
        "embed_url": "//drive.google.com/file/d/1J3hAEe2dBPi37orQHmVv-wel3iLlERgO/preview",
        "speakerdeck": {
          "data_id": "",
          "data_ratio": ""
        }
      }
    },
    "en": {
      "title": "Onboarding process of the Scala team",
      "detail": "Scala is unique in its flexibility and expressiveness. On the other hand, such aspects sometimes make it hard for newcomer to catch up with the coding style of team.\nIn this session, I will share our Scala team's \"Onboarding\" process and tools to make teamwork work.\n\nI'll also talk about topics that might be useful to newcomers, such as how to apply Scala's language features to production code and learning resources.",
      "language": "Japanese",
      "length": 40,
      "tags": [
        "Tools",
        " Scala Beginners (~1year)",
        " Others"
      ],
      "keywords": [
        "knowledge sharing",
        "employee experience"
      ],
      "speakers": [
        {
          "name": "Shunsuke Tadokoro",
          "icon": "https://avatars2.githubusercontent.com/u/2328540?s=460&v=4",
          "organization": "株式会社ビズリーチ",
          "speaker_experience": [
            "ScalaMatsuri 2019 「Running Scala on AWS Lambda in a Snappy Way」 ( https://speakerdeck.com/todokr/running-scala-on-aws-lambda-in-a-snappy-way )",
            "JJUG CCC 2017 Fall 「新しいプログラミング言語の学び方 HTTPサーバーを作って学ぶJava, Scala, Clojure」( https://speakerdeck.com/todokr/xin-siihurokuraminkuyan-yu-falsexue-hifang-httpsahawozuo-tutexue-hu-java-scala-clojure )"
          ],
          "contributes": [],
          "github": "todokr",
          "twitter": "todokr",
          "other_sns": ""
        },
        {
          "name": "Robert Devlin",
          "icon": "https://avatars2.githubusercontent.com/u/49631740?s=460&u=4fbd12e0778c01518833ec7ee52775144ef152fa&v=4",
          "organization": "株式会社ビズリーチ",
          "speaker_experience": [],
          "contributes": [],
          "github": "",
          "twitter": "",
          "other_sns": ""
        }
      ]
    },
    "ja": {
      "title": "Scalaチームのオンボーディング",
      "detail": "Scalaの特色として挙げられるのが、柔軟性や抽象度の高いコードを記述できる表現力です。一方、それゆえにチームのコーディングスタイルへの新メンバーのキャッチアップが難しくなってしまうこともしばしばあります。\nこのセッションでは、新メンバーの入社前から業務の開始、活躍に至るまでの「オンボーディング」の取り組みや、活用しているツールを共有します。\n\n主なテーマは「Scala未経験の新メンバーをチームはどのようにサポートするか」ですが、Scalaの言語機能をどのように活かすかや、学習リソースの紹介など、入門者の方に役立つかもしれないトピックについてもお話ししたいと思います。",
      "language": "Japanese",
      "length": 40,
      "tags": [
        "Tools",
        " Scalaビギナー（Scala歴1年くらいまで）",
        " Others"
      ],
      "keywords": [
        "knowledge sharing",
        "employee experience"
      ],
      "speakers": [
        {
          "name": "田所 駿佑",
          "icon": "https://avatars2.githubusercontent.com/u/2328540?s=460&v=4",
          "organization": "株式会社ビズリーチ",
          "speaker_experience": [
            "ScalaMatsuri 2019 「Running Scala on AWS Lambda in a Snappy Way」 ( https://speakerdeck.com/todokr/running-scala-on-aws-lambda-in-a-snappy-way )",
            "JJUG CCC 2017 Fall 「新しいプログラミング言語の学び方 HTTPサーバーを作って学ぶJava, Scala, Clojure」( https://speakerdeck.com/todokr/xin-siihurokuraminkuyan-yu-falsexue-hifang-httpsahawozuo-tutexue-hu-java-scala-clojure )"
          ],
          "contributes": [],
          "github": "todokr",
          "twitter": "todokr",
          "other_sns": ""
        },
        {
          "name": "Robert Devlin",
          "icon": "https://avatars2.githubusercontent.com/u/49631740?s=460&u=4fbd12e0778c01518833ec7ee52775144ef152fa&v=4",
          "organization": "株式会社ビズリーチ",
          "speaker_experience": [],
          "contributes": [],
          "github": "",
          "twitter": "",
          "other_sns": ""
        }
      ]
    }
  },
  {
    "id": "J22",
    "artifacts": {
      "youtube_embed_url": "//www.youtube.com/embed/gpQHgcIIzFY",
      "slides": {
        "other_url": "https://github.com/knih/scalamatsuri2020/blob/master/slides/intro-msp-with-dotty.pdf",
        "embed_url": "",
        "speakerdeck": {
          "data_id": "",
          "data_ratio": ""
        }
      }
    },
    "en": {
      "title": "An introduction to multi-stage programming with Dotty",
      "detail": "Multi-stage programming (MSP) is a kind of meta-programming that enables type-safe runtime code generation and abstraction without regrets.\nDotty (Scala 3) has enhanced the meta-programming mechanism to allow MSP.\nIn this session, we will talk about the concept of MSP and how to write its program, and an approach combining MSP and tagless-final.",
      "language": "Japanese",
      "length": 40,
      "tags": [
        "Functional Programming"
      ],
      "keywords": [
        "Generative Programming",
        "Abstraction without Regret",
        "tagless-final"
      ],
      "speakers": [
        {
          "name": "Kenichi Suzuki",
          "icon": "https://avatars2.githubusercontent.com/u/16099864?s=460&v=4",
          "organization": "Visional Incubation",
          "speaker_experience": [
            "Scala秋祭り (https://speakerdeck.com/dcubeio/from-tagless-final-to-typed-final-program-transformations-in-the-final-style)"
          ],
          "contributes": [],
          "github": "",
          "twitter": "",
          "other_sns": ""
        }
      ]
    },
    "ja": {
      "title": "Dotty ではじめるマルチステージプログラミング入門",
      "detail": "マルチステージプログラミング (MSP) は、型安全な実行時コード生成と、オーバーヘッドのない抽象化を可能とするメタプログラミングの一種です。\nDotty (Scala 3) ではメタプログラミング機構が強化され、MSP が可能になりました。\nこのセッションでは、 MSP の概念やその基本的なプログラムの書き方、 さらに tagless-final と組み合わせた実用的で高性能なDSL構築アプローチについてお話します。",
      "language": "Japanese",
      "length": 40,
      "tags": [
        "Functional Programming"
      ],
      "keywords": [
        "Generative Programming",
        "Abstraction without Regret",
        "tagless-final"
      ],
      "speakers": [
        {
          "name": "鈴木 健一",
          "icon": "https://avatars2.githubusercontent.com/u/16099864?s=460&v=4",
          "organization": "ビジョナル・インキュベーション株式会社",
          "speaker_experience": [
            "Scala秋祭り (https://speakerdeck.com/dcubeio/from-tagless-final-to-typed-final-program-transformations-in-the-final-style)"
          ],
          "contributes": [],
          "github": "",
          "twitter": "",
          "other_sns": ""
        }
      ]
    }
  },
  {
    "id": "J24",
    "artifacts": {
      "youtube_embed_url": "//www.youtube.com/embed/cmgIXnhs5mE",
      "slides": {
        "other_url": "",
        "embed_url": "//www.slideshare.net/slideshow/embed_code/key/1h01MMqdppTivV",
        "speakerdeck": {
          "data_id": "",
          "data_ratio": ""
        }
      }
    },
    "en": {
      "title": "Akka Streams vs Spark Structured  Streaming",
      "detail": "Akka Streams and Spark Structured Streaming are way to implement streaming for big data.\nSo, which is better?\nHow about the power of expression, reliable, responsive, elastic, resilient.\nI'll explain the overview and compare these worrisome parts and introduce techniques for clearing the issues.",
      "language": "Japanese",
      "length": 40,
      "tags": [
        "Big Data / Fast Data",
        " Software Design and Architecture"
      ],
      "keywords": [
        "Akka Streams",
        "Spark",
        "Structured  Streaming"
      ],
      "speakers": [
        {
          "name": "Kosuke Yabumoto",
          "icon": "/img/speakers/J24.png",
          "organization": "株式会社ジオロジック CTO",
          "speaker_experience": [
            "#6 市ヶ谷Geek★Night「アドテク百花繚乱」",
            "https://ichigayageek.connpass.com/event/27420/"
          ],
          "contributes": [],
          "github": "glyabumoto",
          "twitter": "@yabooun",
          "other_sns": "Facebook: https://www.facebook.com/kousuke.yabumoto.9"
        }
      ]
    },
    "ja": {
      "title": "Akka Streams vs Spark Structured  Streaming",
      "detail": "大量データへのストリーミング処理の実装方法として、Akka StreamsとSpark Structured Streamingがあります。\n\nでは、実案件ではどちらを採用すべきでしょうか。\n仕様の表現力、信頼性、即応性、弾力性、耐障害性などはどうでしょうか。\n\nこの２つについて概要および簡単な使い方を説明し、気になる部分を比較して、課題をクリアするテクニックを紹介します。",
      "language": "Japanese",
      "length": 40,
      "tags": [
        "Big Data / Fast Data",
        " Software Design and Architecture"
      ],
      "keywords": [
        "Akka Streams",
        "Spark",
        "Structured  Streaming"
      ],
      "speakers": [
        {
          "name": "藪本晃輔",
          "icon": "/img/speakers/J24.png",
          "organization": "株式会社ジオロジック CTO",
          "speaker_experience": [
            "#6 市ヶ谷Geek★Night「アドテク百花繚乱」",
            "https://ichigayageek.connpass.com/event/27420/"
          ],
          "contributes": [],
          "github": "glyabumoto",
          "twitter": "@yabooun",
          "other_sns": "Facebook: https://www.facebook.com/kousuke.yabumoto.9"
        }
      ]
    }
  },
  {
    "id": "J26",
    "artifacts": {
      "youtube_embed_url": "//www.youtube.com/embed/0B81qSzQhss",
      "slides": {
        "other_url": "",
        "embed_url": "",
        "speakerdeck": {
          "data_id": "e1a89af9f06447ce9788c3837ea0b416",
          "data_ratio": "1.33333333333333"
        }
      }
    },
    "en": {
      "title": "Making of SaaS backend, guided by PofEAA",
      "detail": "On SaaS development scenes, mature design skill is required to make code refrect complex business models.In that situation, Martin Fowler's \"Patterns of Enterprise Application Architecture\" is still a powerful source of idea even after the times.In this session, I will explain Implementation of SaaS backend API using patterns from PofEAA.\n\nIt may be difficult to understand Scala's OO and FP characteristics simultaneously for beginners.I think that focusing OO aspect is helpful for them.PofEAA contains a lot of hints for writing well Object Oriented code.Of course they can be applied to Scala.",
      "language": "Japanese",
      "length": 40,
      "tags": [
        "Best Practices",
        " Scala Beginners (~1year)",
        " Software Design and Architecture"
      ],
      "keywords": [
        "OOP",
        "RDB",
        "PofEAA"
      ],
      "speakers": [
        {
          "name": "Kenichi Tanga",
          "icon": "/img/speakers/J26.jpg",
          "organization": "アルプ株式会社 エンジニア",
          "speaker_experience": [
            "PHPカンファレンス福岡2018",
            "PHPカンファレンス仙台2019"
          ],
          "contributes": [],
          "github": "dnskimo",
          "twitter": "dnskimox",
          "other_sns": ""
        }
      ]
    },
    "ja": {
      "title": "PofEAAで考えるSaaSバックエンドの作り方",
      "detail": "SaaSの開発現場では複雑なビジネスモデルをコードに落とし込むため、地に足のついた設計技能が不可欠です。そんな時、Martin Fowler氏の著した『Patterns of Enterprise Application Architecture』は、時代を経た今でも十分有力な情報源になります。このセッションではPofEAAのパターンを用いてSaaSのバックエンドAPIを実装する方法を解説します。\n\nScala初学者にとってオブジェクト指向と関数型の性質を同時に理解するのはハードルが高いかもしれません。そこでまずはScalaのオブジェクト指向の側面に着目してみるのはどうでしょうか。PofEAAにはオブジェクト指向らしいコードを書くためのヒントが散りばめられています。もちろんそれらはScalaにも適用可能です",
      "language": "Japanese",
      "length": 40,
      "tags": [
        "Best Practices",
        " Scalaビギナー（Scala歴1年くらいまで）",
        " Software Design and Architecture"
      ],
      "keywords": [
        "OOP",
        "RDB",
        "PofEAA"
      ],
      "speakers": [
        {
          "name": "丹賀 健一",
          "icon": "/img/speakers/J26.jpg",
          "organization": "アルプ株式会社 エンジニア",
          "speaker_experience": [
            "PHPカンファレンス福岡2018",
            "PHPカンファレンス仙台2019"
          ],
          "contributes": [],
          "github": "dnskimo",
          "twitter": "dnskimox",
          "other_sns": ""
        }
      ]
    }
  },
  {
    "id": "J27",
    "artifacts": {
      "youtube_embed_url": "//www.youtube.com/embed/dQsTyzb8sUc",
      "slides": {
        "other_url": "",
        "embed_url": "//gakuzzzz.github.io/slides/scala_from_other_languages/index.html",
        "speakerdeck": {
          "data_id": "",
          "data_ratio": ""
        }
      }
    },
    "en": {
      "title": "Beginning Scala from zero for other language exparts: ~block exp, for exp, type classes",
      "detail": "Scala is sometimes said to be expensive to learn.\n\nThe existence of language mechanisms that are difficult to analogize from the experience of other languages,\nIn other languages, specially prepared functions are realized by a combination of simple functions,\nso, some people feel difficult to learn.\n\nIn this session, it ’s helpful to know first,\nI would like to explain the effective language mechanisms that are difficult to learn by analogy from other languages.\n\nSome language mechanisms that are difficult to learn by analogy from other languages.\nSpecifically those are \"\"block expression\"\", \"\"for expression\"\", and \"\"implicit parameter\"\".",
      "language": "Japanese",
      "length": 40,
      "tags": [
        "Best Practices",
        " Scala Beginners (~1year)",
        " Others"
      ],
      "keywords": [
        ""
      ],
      "speakers": [
        {
          "name": "NAKAMURA Manabu (gakuzzzz)",
          "icon": "https://pbs.twimg.com/profile_images/1431608839/ceb5e4f7-bec8-4a68-a86c-32d0c7ae4e22_400x400.png",
          "organization": "",
          "speaker_experience": [
            "Scala関西Summit2019 https://gakuzzzz.github.io/slides/lightweight_clean_architecture_with_dmt/",
            "ScalaMatsuri2019 https://gakuzzzz.github.io/slides/cps_or_di/",
            "BuriKaigi2020 https://gakuzzzz.github.io/slides/type_safe_builder_in_java/",
            ""
          ],
          "contributes": [],
          "github": "gakuzzzz",
          "twitter": "gakuzzzz",
          "other_sns": ""
        }
      ]
    },
    "ja": {
      "title": "他言語経験者が0から始めるScala ～block式とfor式と型クラス～",
      "detail": "Scalaは時折、学習コストが高いと言われる事があります。\n元々持っている他言語の経験から類推しにくい言語機構の存在や、他言語では専用で用意されている機能が、シンプルな機能の組み合わせで実現されていたりする事から、取っ付きづらさを感じてしまう方もいらっしゃる様です。\n\nこのセッションでは、最初に知っておくと理解が進みやすかったり、実務で効果を発揮しやすかったりするものの、なかなか他言語からの類推では学習し難い言語機構について、簡単に解説したいと思います。\n\n他言語からの類推では学習し難い言語機構。具体的には block式、for式、implicit parameter という言語機構について解説します。",
      "language": "Japanese",
      "length": 40,
      "tags": [
        "Best Practices",
        " Scalaビギナー（Scala歴1年くらいまで）",
        " Others"
      ],
      "keywords": [
        ""
      ],
      "speakers": [
        {
          "name": "中村 学（がくぞ）",
          "icon": "https://pbs.twimg.com/profile_images/1431608839/ceb5e4f7-bec8-4a68-a86c-32d0c7ae4e22_400x400.png",
          "organization": "",
          "speaker_experience": [
            "Scala関西Summit2019 https://gakuzzzz.github.io/slides/lightweight_clean_architecture_with_dmt/",
            "ScalaMatsuri2019 https://gakuzzzz.github.io/slides/cps_or_di/",
            "BuriKaigi2020 https://gakuzzzz.github.io/slides/type_safe_builder_in_java/",
            ""
          ],
          "contributes": [],
          "github": "gakuzzzz",
          "twitter": "gakuzzzz",
          "other_sns": ""
        }
      ]
    }
  },
  {
    "id": "J20",
    "artifacts": {
      "youtube_embed_url": "//www.youtube.com/embed/V8QR92XciTc",
      "slides": {
        "other_url": "",
        "embed_url": "//www.slideshare.net/slideshow/embed_code/key/B1w0ZTZcXPlFvT",
        "speakerdeck": {
          "data_id": "",
          "data_ratio": ""
        }
      }
    },
    "en": {
      "title": "liberty, equality, and boxed primitive types",
      "detail": "In this talk, I will explore the equality in Scala. == is seemingly easy, but it's actually a complicated topic.\n\nThe Scala Language Spec doesn't explain much about equality. We'll try to revisit some of the past discussions and think how == actually behave.",
      "language": "Japanese",
      "length": 40,
      "tags": [
        "Others"
      ],
      "keywords": [
        "scala",
        "equality",
        "language design"
      ],
      "speakers": [
        {
          "name": "Eugene Yokota (eed3si9n)",
          "icon": "https://secure.gravatar.com/avatar/8f41595db400be30176f6f04630c2842",
          "organization": "Twitter",
          "speaker_experience": [
            "Scala Days",
            "Scala Sphere",
            "nescala"
          ],
          "contributes": [
            "sbt",
            "Zinc",
            "Scala"
          ],
          "github": "eed3si9n",
          "twitter": "eed3si9n_ja",
          "other_sns": ""
        }
      ]
    },
    "ja": {
      "title": "自由、平等、ボックス化されたプリミティブ型",
      "detail": "Scala における等価性に関して考察します。== は一見簡単そうに見えて実は複雑なトピックです。\n\nScala の言語仕様は等価性に関してあまり詳しく書いてありません。過去の議論などをさかのぼって == がどう振る舞うのかを考えてみましょう。",
      "language": "Japanese",
      "length": 40,
      "tags": [
        "Others"
      ],
      "keywords": [
        "scala",
        "equality",
        "language design"
      ],
      "speakers": [
        {
          "name": "Eugene Yokota (eed3si9n)",
          "icon": "https://secure.gravatar.com/avatar/8f41595db400be30176f6f04630c2842",
          "organization": "Twitter",
          "speaker_experience": [
            "Scala Days",
            "Scala Sphere",
            "nescala"
          ],
          "contributes": [
            "sbt",
            "Zinc",
            "Scala"
          ],
          "github": "eed3si9n",
          "twitter": "eed3si9n_ja",
          "other_sns": ""
        }
      ]
    }
  },
  {
    "id": "E29",
    "artifacts": {
      "youtube_embed_url": "//www.youtube.com/embed/t4yJCDB-_H4",
      "slides": {
        "other_url": "",
        "embed_url": "//drive.google.com/file/d/1Z9blolF6wdc88W2AwKVj5VYbnaW95JUUSRnY8K-zi8Q/preview",
        "speakerdeck": {
          "data_id": "",
          "data_ratio": ""
        }
      }
    },
    "en": {
      "title": "First-Class Type-Level Programming",
      "detail": "Scala already supports type-level programming through implicits, but can we do better? In this talk we introduce \"match types\", i.e., type functions, arriving in Scala 3.0 and some of their use cases. We also explore how the language could evolve to support fully-fledged dependent types.",
      "language": "English",
      "length": 40,
      "tags": [
        "Functional Programming",
        " Others"
      ],
      "keywords": [
        "type-level programming",
        "match types",
        "dependent types"
      ],
      "speakers": [
        {
          "name": "Georg Schmid",
          "icon": "https://avatars2.githubusercontent.com/u/2364189?s=460&v=4",
          "organization": "EPFL",
          "speaker_experience": [],
          "contributes": [
            "Dotty, Stainless, V8"
          ],
          "github": "gsps",
          "twitter": "",
          "other_sns": ""
        },
        {
          "proposalId": "E29",
          "name": "Olivier Blanvillain",
          "icon": "https://people.epfl.ch/private/common/photos/links/184098.jpg",
          "organization": "EPFL",
          "speaker_experience": [
            "Scala Days Berlin 2018"
          ],
          "contributes": [
            "Dotty, Frameless, Monadic-html"
          ],
          "github": "olivierblanvillain",
          "twitter": "",
          "other_sns": ""
        }
      ]
    },
    "ja": {
      "title": "第1級の型レベルプログラミング",
      "detail": "Scalaはすでにimplicitを通じて型レベルプログラミングをサポートしていますが、よりうまくやる方法はないでしょうか？\n\nこのトークでは、Scala 3に導入された \"match types\" や、型レベルの関数について解説しつつ、そのユースケースについても紹介します。そして本格的な依存型のサポートへ向けて、さらにどのように進化できるのかについて探ります。",
      "language": "English",
      "length": 40,
      "tags": [
        "Functional Programming",
        " Others"
      ],
      "keywords": [
        "type-level programming",
        "match types",
        "dependent types"
      ],
      "speakers": [
        {
          "name": "Georg Schmid",
          "icon": "https://avatars2.githubusercontent.com/u/2364189?s=460&v=4",
          "organization": "EPFL",
          "speaker_experience": [],
          "contributes": [
            "Dotty, Stainless, V8"
          ],
          "github": "gsps",
          "twitter": "",
          "other_sns": ""
        },
        {
          "proposalId": "E29",
          "name": "Olivier Blanvillain",
          "icon": "https://people.epfl.ch/private/common/photos/links/184098.jpg",
          "organization": "EPFL",
          "speaker_experience": [
            "Scala Days Berlin 2018"
          ],
          "contributes": [
            "Dotty, Frameless, Monadic-html"
          ],
          "github": "olivierblanvillain",
          "twitter": "",
          "other_sns": ""
        }
      ]
    }
  }
]
